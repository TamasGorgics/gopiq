{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A fluent, thread-safe Go image processing library with chainable operations.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fluent Interface: Chain multiple operations together naturally</li> <li>Thread-Safe: Safe for concurrent use by multiple goroutines</li> <li>High-Quality Processing: Uses Catmull-Rom interpolation for resizing</li> <li>Comprehensive Error Handling: Errors propagate through the chain</li> <li>Multiple Format Support: JPEG, PNG input/output</li> <li>Text Watermarks: Add customizable text overlays with font control</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/TamasGorgics/gopiq\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/TamasGorgics/gopiq\"\n)\n\nfunc main() {\n    imageData, err := os.ReadFile(\"img.jpg\")\n    if err != nil {\n        fmt.Printf(\"Error reading image: %v\\n\", err)\n        return\n    }\n\n    // Load and process an image with method chaining\n    processor := gopiq.FromBytes(imageData).\n        Resize(800, 600).\n        Grayscale().\n        Crop(100, 100, 400, 300).\n        AddTextWatermark(\"\u00a9 2025\",\n            gopiq.WithFontSize(24),\n            gopiq.WithPosition(gopiq.PositionBottomRight))\n\n    if processor.Err() != nil {\n        fmt.Printf(\"Error: %v\\n\", processor.Err())\n        return\n    }\n\n    // Export the result\n    resultBytes, err := processor.ToBytes(gopiq.FormatJPEG)\n    if err != nil {\n        fmt.Printf(\"Export error: %v\\n\", err)\n        return\n    }\n\n    err = os.WriteFile(\"output.jpg\", resultBytes, 0644)\n    if err != nil {\n        fmt.Printf(\"Error writing output file: %v\\n\", err)\n        return\n    }\n\n    fmt.Println(\"Image processed and saved successfully\")\n}\n</code></pre>"},{"location":"concurrency/","title":"Concurrency","text":"<p>gopiq is designed to be thread-safe and supports concurrent usage out of the box.</p>"},{"location":"concurrency/#safe-concurrent-reading","title":"Safe Concurrent Reading","text":"<p>Multiple goroutines can safely read from the same processor instance. The library uses <code>sync.RWMutex</code> to ensure that read operations do not conflict with write operations.</p> <pre><code>proc := gopiq.New(image).Resize(800, 600).Grayscale()\n\n// Multiple goroutines can safely call these concurrently:\ngo func() {\n    img, err := proc.Image()\n    // Use img...\n}()\n\ngo func() {\n    bytes, err := proc.ToBytes(gopiq.FormatPNG)\n    // Use bytes...\n}()\n</code></pre>"},{"location":"concurrency/#clone-for-independent-processing","title":"Clone for Independent Processing","text":"<p>For parallel write operations, you should create independent copies of the processor. The <code>Clone()</code> method creates a shallow copy of the processor that is safe to use in a separate goroutine.</p> <pre><code>original := gopiq.New(image)\n\n// Each goroutine gets its own independent processor\nfor i := 0; i &lt; 10; i++ {\n    go func() {\n        processor := original.Clone().\n            Resize(100, 100).\n            AddTextWatermark(\"Processed\")\n        // Process independently...\n    }()\n}\n</code></pre>"},{"location":"concurrency/#concurrent-processing-pattern","title":"Concurrent Processing Pattern","text":"<p>Here is a common pattern for processing multiple images in parallel.</p> <pre><code>func processImagesInParallel(images []image.Image) []*gopiq.ImageProcessor {\n    results := make([]*gopiq.ImageProcessor, len(images))\n    var wg sync.WaitGroup\n\n    for i, img := range images {\n        wg.Add(1)\n        go func(index int, image image.Image) {\n            defer wg.Done()\n            results[index] = gopiq.New(image).\n                Resize(200, 200).\n                Grayscale()\n        }(i, img)\n    }\n\n    wg.Wait()\n    return results\n}\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>gopiq includes advanced performance optimizations that can provide dramatic speed improvements.</p>"},{"location":"performance/#optimized-methods","title":"\ud83d\ude80 Optimized Methods","text":""},{"location":"performance/#grayscalefast-parallel-processing","title":"GrayscaleFast() - Parallel Processing","text":"<p>For large images, use <code>GrayscaleFast()</code> instead of <code>Grayscale()</code>:</p> <pre><code>// Up to 33x faster for large images (1920x1080)\nprocessor := gopiq.New(image).GrayscaleFast()\n</code></pre>"},{"location":"performance/#performance-results-500x500-images-on-apple-m1-pro","title":"Performance Results (500x500 images on Apple M1 Pro):","text":"<ul> <li>Slow method (At/Set): 7.17ms, 3MB allocations </li> <li>Optimized method: 735\u03bcs, 1MB allocations (9.7x faster)</li> <li>Parallel method: 276\u03bcs, 1MB allocations (26x faster)</li> </ul>"},{"location":"performance/#performance-configuration","title":"\u26a1 Performance Configuration","text":"<pre><code>// Custom performance settings\nopts := gopiq.PerformanceOptions{\n    MaxGoroutines:            8,     // Limit parallel goroutines\n    EnableParallelProcessing: true,  // Enable parallel processing\n    MinSizeForParallel:       10000, // Minimum pixels for parallel\n}\n\nprocessor := gopiq.NewWithPerformanceOptions(image, opts)\n</code></pre>"},{"location":"performance/#scalability","title":"\ud83d\udcca Scalability","text":"<p>Parallel Processing Performance (1920x1080 images): - 1 goroutine: 5.87ms - 2 goroutines: 3.11ms (1.9x faster) - 4 goroutines: 1.77ms (3.3x faster) - 8 goroutines: 1.23ms (4.8x faster)</p>"},{"location":"performance/#optimization-techniques","title":"\ud83d\udd27 Optimization Techniques","text":"<ol> <li>Direct Buffer Access: Bypasses Go's interface overhead</li> <li>Parallel Processing: Utilizes multiple CPU cores automatically</li> <li>Memory Pooling: Reduces garbage collection pressure</li> <li>SIMD-friendly Operations: CPU-optimized pixel processing</li> <li>ITU-R BT.709 Grayscale: Professional-grade color conversion </li> </ol>"},{"location":"api/core/","title":"API Reference","text":"<p>This section covers the core methods for creating and managing <code>ImageProcessor</code> instances.</p> <ul> <li><code>New(img image.Image) *ImageProcessor</code> - Create processor from image</li> <li><code>FromBytes(data []byte) *ImageProcessor</code> - Create processor from image bytes</li> <li><code>Clone() *ImageProcessor</code> - Create independent copy</li> <li><code>Image() (image.Image, error)</code> - Get current image</li> <li><code>ToBytes(format ImageFormat) ([]byte, error)</code> - Export to bytes</li> <li><code>Err() error</code> - Get any error from the processing chain </li> </ul>"},{"location":"api/operations/","title":"Processing Operations","text":"<p>These methods are chainable and perform image manipulation.</p> <ul> <li><code>Resize(width, height int)</code> - Resize using Catmull-Rom interpolation</li> <li><code>Crop(x, y, width, height int)</code> - Crop to specified rectangle</li> <li><code>Grayscale()</code> - Convert to grayscale</li> <li><code>GrayscaleFast()</code> - Convert to grayscale using parallel processing for a significant speed boost.</li> <li><code>AddTextWatermark(text, ...options)</code> - Add text watermark </li> </ul>"},{"location":"api/watermark/","title":"Watermark Options","text":"<p>Use these functional options to customize text watermarks.</p> <ul> <li><code>WithFontSize(size float64)</code> - Set font size</li> <li><code>WithColor(color color.Color)</code> - Set text color</li> <li><code>WithPosition(pos WatermarkPosition)</code> - Set position</li> <li><code>WithOffset(x, y float64)</code> - Set offset from position</li> <li><code>WithFontBytes(data []byte)</code> - Use custom font </li> </ul>"}]}